# src/core/trading_bot.py (VERS√ÉO FINAL COM CALCULADORA DE FEATURES)

import time
import pandas as pd
import uuid
from datetime import datetime, timezone
import signal
import sys
import json
import os
from typing import Any

from jules_bot.utils.logger import logger
from jules_bot.utils.config_manager import settings
from jules_bot.bot.position_manager import PositionManager
from jules_bot.core.exchange_connector import ExchangeManager
from jules_bot.bot.account_manager import AccountManager
from jules_bot.database.database_manager import DatabaseManager
from jules_bot.database.data_manager import DataManager
# --- NOVA IMPORTA√á√ÉO ESSENCIAL ---
from jules_bot.bot.live_feature_calculator import LiveFeatureCalculator

class TradingBot:
    """
    O maestro que orquestra todos os componentes do bot, utilizando um
    calculador de features em tempo real para tomar decis√µes.
    """

    def __init__(self, mode: str = 'trade'):
        self.mode = mode
        logger.info(f"--- INICIALIZANDO O TRADING BOT EM MODO '{self.mode.upper()}' ---")

        # --- ETAPA 1: Constru√ß√£o dos Managers ---
        logger.info("Construindo e injetando depend√™ncias...")
        # Instancia o DatabaseManager com o modo de execu√ß√£o correto
        self.db_manager = DatabaseManager(execution_mode=self.mode)
        exchange_manager = ExchangeManager(mode=self.mode)
        self.account_manager = AccountManager(binance_client=exchange_manager._client)
        data_manager = DataManager(db_manager=self.db_manager, config=settings, logger=logger)
        self.feature_calculator = LiveFeatureCalculator(data_manager, mode=self.mode)
        self.position_manager = PositionManager(
            config=settings,
            db_manager=self.db_manager,
            logger=logger,
            account_manager=self.account_manager
        )
        
        self.symbol = settings.app.symbol

        # --- ETAPA 2: SINCRONIZA√á√ÉO DE POSI√á√ïES (NOVO BLOCO) ---
        # Este bloco garante que o bot "conhe√ßa" os trades feitos anteriormente.
        if self.mode in ['test', 'trade']:
            logger.info("Iniciando processo de sincroniza√ß√£o de trades √≥rf√£os...")
            try:
                # a) Busque os trades recentes da corretora (ex: √∫ltimos 100)
                recent_trades_df = self.account_manager.get_trade_history(limit=100)

                # A API retorna uma lista. A verifica√ß√£o correta √© se a lista n√£o est√° vazia.
                if recent_trades_df:
                    # b) Busque dados hist√≥ricos com features (ATR) para calcular os alvos
                    historical_data_df = data_manager.read_data_from_influx(
                        measurement="features_master_table", 
                        start_date="-3d" # Garante cobertura para trades dos √∫ltimos dias
                    )

                    if not historical_data_df.empty:
                        # c) Execute a sincroniza√ß√£o
                        self.position_manager.synchronize_with_exchange(
                            recent_exchange_trades=pd.DataFrame(recent_trades_df),
                            historical_data=historical_data_df
                        )
                    else:
                        logger.warning("N√£o foi poss√≠vel carregar dados hist√≥ricos para o c√°lculo do ATR. Sincroniza√ß√£o pulada.")
                else:
                    logger.info("Nenhum trade encontrado na corretora para sincronizar.")
            except Exception as e:
                logger.error(f"Falha durante a sincroniza√ß√£o de trades: {e}", exc_info=True)

        # --- ETAPA 2.5: VERIFICA√á√ÉO E ADO√á√ÉO DE ORDENS ABERTAS INESPERADAS ---
        try:
            open_orders = self.account_manager.get_open_orders()
            if open_orders:
                logger.warning(f"üö® {len(open_orders)} ordens abertas encontradas na Binance. Tentando adot√°-las como posi√ß√µes... üö®")

                # Re-usa os dados hist√≥ricos j√° carregados se poss√≠vel, ou carrega-os novamente.
                if 'historical_data_df' not in locals() or historical_data_df.empty:
                    historical_data_df = data_manager.read_data_from_influx(
                        measurement="features_master_table",
                        start_date="-3d"
                    )

                if historical_data_df.empty:
                    logger.error("N√£o foi poss√≠vel carregar dados hist√≥ricos para o c√°lculo do ATR. Ado√ß√£o de ordens pulada.")
                else:
                    # Obter posi√ß√µes abertas para evitar adotar uma ordem que j√° corresponde a uma posi√ß√£o
                    open_positions = self.position_manager.get_open_positions()
                    # Extrair IDs de ordens j√° associadas a posi√ß√µes
                    linked_order_ids = []
                    if not open_positions.empty:
                        for data in open_positions.get('decision_data', []):
                            if isinstance(data, dict) and data.get('binance_order_id'):
                                linked_order_ids.append(data['binance_order_id'])

                    for order in open_orders:
                        if order['orderId'] in linked_order_ids:
                            continue

                        logger.info(f"Adotando ordem √≥rf√£ ID: {order['orderId']}...")

                        trade_timestamp = pd.to_datetime(order['time'], unit='ms', utc=True)
                        candle = historical_data_df.asof(trade_timestamp)

                        if pd.isna(candle.get('atr_14')):
                            logger.warning(f"N√£o foi poss√≠vel encontrar ATR para a ordem {order['orderId']}. Ado√ß√£o pulada.")
                            continue

                        entry_price = float(order['price'])
                        quantity_btc = float(order['origQty'])
                        atr_value = candle['atr_14']

                        trade_data = {
                            "trade_id": str(uuid.uuid4()),
                            "status": "OPEN",
                            "entry_price": entry_price,
                            "quantity_btc": quantity_btc,
                            "profit_target_price": entry_price + (atr_value * self.position_manager.profit_target_mult),
                            "stop_loss_price": entry_price - (atr_value * self.position_manager.stop_loss_mult),
                            "timestamp": trade_timestamp,
                            "decision_data": {"reason": "ADOPTED_FROM_OPEN_ORDER", "binance_order_id": order['orderId']},
                        }
                        self.position_manager.db_manager.write_trade(trade_data)
                        logger.info(f"‚úÖ Posi√ß√£o para a ordem Binance ID {order['orderId']} adotada com sucesso.")

        except Exception as e:
            logger.error(f"Falha ao verificar/adotar ordens abertas durante a inicializa√ß√£o: {e}", exc_info=True)


        # --- ETAPA 3: Finaliza√ß√£o da Inicializa√ß√£o ---
        self.is_running = True
        signal.signal(signal.SIGINT, self.graceful_shutdown)
        signal.signal(signal.SIGTERM, self.graceful_shutdown)
        logger.info("‚úÖ Bot inicializado com sucesso. Pressione Ctrl+C para encerrar.")



    def run(self):
        """
        O loop principal que executa a l√≥gica de trading a cada minuto.
        """
        logger.info(f"üöÄ --- LOOP PRINCIPAL INICIADO PARA O S√çMBOLO {self.symbol} --- üöÄ")
        while self.is_running:
            try:
                # --- ETAPA 1: OBTER A VELA ATUAL COM TODAS AS FEATURES CALCULADAS ---
                current_candle = self.feature_calculator.get_current_candle_with_features()

                if current_candle.empty:
                    logger.error("N√£o foi poss√≠vel gerar a vela de decis√£o. A saltar ciclo.")
                    time.sleep(60)
                    continue
                
                logger.info(f"Pre√ßo atual de {self.symbol}: ${current_candle['close']:,.2f} | ATR(14): {current_candle.get('atr_14', 0.0):.2f}")

                # --- ETAPA 2: EXECUTAR A L√ìGICA DE TRADING ---
                
                # Verificar sa√≠das (TP/SL)
                closed_trades = self.position_manager.check_and_close_positions(current_candle)
                if closed_trades:
                    for trade in closed_trades:
                        logger.info(f"‚úÖ POSI√á√ÉO FECHADA ({trade['exit_reason']}): P&L de ${trade['pnl_usdt']:.2f} realizado.")

                # Verificar entradas
                buy_decision = self.position_manager.check_for_entry(current_candle)

                # Executar a compra
                if buy_decision:
                    logger.info(f"DECIS√ÉO DE COMPRA: Motivo='{buy_decision.get('reason', 'N/A')}'. Tentando abrir posi√ß√£o...")
                    self.position_manager.open_position(current_candle, buy_decision)
                else:
                    logger.info("Nenhuma condi√ß√£o de entrada satisfeita. A aguardar.")
                
                self._update_status_file(current_candle)

                logger.info("--- Ciclo conclu√≠do. A aguardar 60 segundos... ---")
                time.sleep(60)

            except Exception as e:
                logger.critical(f"‚ùå Ocorreu um erro cr√≠tico no loop principal: {e}", exc_info=True)
                logger.info("A aguardar 5 minutos antes de reiniciar o loop para evitar spam de erros.")
                time.sleep(300)

    def _update_status_file(self, current_candle: pd.Series):
        """Coleta dados de status e os escreve em um arquivo JSON."""
        try:
            # 1. Dados do Portf√≥lio
            btc_balance = self.account_manager.get_base_asset_balance()
            usd_balance = self.account_manager.get_quote_asset_balance()
            current_price = current_candle['close']
            btc_value_usdt = btc_balance * current_price
            total_value_usdt = usd_balance + btc_value_usdt

            # --- C√°lculos de M√©tricas de Portf√≥lio Detalhadas ---
            all_trades_for_metrics = self.db_manager.get_all_trades_in_range(start_date="-1y")
            btc_for_sale = 0
            btc_treasure = 0

            if not all_trades_for_metrics.empty:
                open_positions_metrics = all_trades_for_metrics[all_trades_for_metrics['status'] == 'OPEN']
                if not open_positions_metrics.empty:
                    btc_for_sale = open_positions_metrics['quantity_btc'].sum()

                treasure_trades = all_trades_for_metrics[
                    (all_trades_for_metrics['status'] == 'CLOSED') &
                    (all_trades_for_metrics['decision_data'].apply(
                        lambda x: isinstance(x, dict) and x.get('exit_reason') == 'TAKE_PROFIT_PARTIAL'
                    ))
                ]
                if not treasure_trades.empty:
                    btc_treasure = treasure_trades['quantity_btc'].sum()

            portfolio_data = {
                "btc_balance": btc_balance, # Saldo total na wallet
                "usd_balance": usd_balance,
                "btc_for_sale": btc_for_sale, # BTC em posi√ß√µes abertas
                "btc_treasure": btc_treasure, # BTC acumulado de vendas parciais
                "btc_value_usdt": btc_value_usdt,
                "total_value_usdt": total_value_usdt,
                "current_price": current_price
            }

            # 2. Estat√≠sticas da Sess√£o e Posi√ß√µes Abertas
            all_trades = self.db_manager.get_all_trades_in_range(start_date="-1y")
            total_pnl = 0
            closed_trades_count = 0
            open_positions_count = 0
            open_positions_summary = []

            if not all_trades.empty:
                closed_trades = all_trades[all_trades['status'] == 'CLOSED']
                if not closed_trades.empty:
                    total_pnl = closed_trades['realized_pnl_usdt'].sum()
                closed_trades_count = len(closed_trades)

                open_positions = all_trades[all_trades['status'] == 'OPEN']
                open_positions_count = len(open_positions)

                # --- NOVA L√ìGICA PARA DETALHAR POSI√á√ïES ABERTAS ---
                commission_rate = self.position_manager.config.backtest.commission_rate
                for _, trade in open_positions.iterrows():
                    entry_price = trade['entry_price']
                    quantity_btc = trade['quantity_btc']

                    # C√°lculos de P&L
                    unrealized_pnl_usdt = (current_price - entry_price) * quantity_btc

                    entry_value = entry_price * quantity_btc
                    current_value = current_price * quantity_btc
                    unrealized_pnl_liquid_usdt = (current_value * (1 - commission_rate)) - (entry_value * (1 + commission_rate))

                    tp_price = trade.get('profit_target_price', 0) # Corrigido para usar o nome correto do campo
                    distance_pct = ((tp_price - current_price) / current_price) * 100 if tp_price > 0 and current_price > 0 else 0
                    
                    open_positions_summary.append({
                        "trade_id": str(trade.name),
                        "entry_price": entry_price,
                        "quantity_btc": quantity_btc,
                        "take_profit_price": tp_price,
                        "target_distance_pct": distance_pct,
                        "unrealized_pnl_usdt": unrealized_pnl_usdt,
                        "unrealized_pnl_liquid_usdt": unrealized_pnl_liquid_usdt,
                        "timestamp": trade['timestamp'].isoformat()
                    })

            session_stats = {
                "total_pnl_usdt": total_pnl,
                "open_positions_count": open_positions_count,
                "closed_trades_count": closed_trades_count
            }

            # 3. Resumo dos √öltimos 5 Trades (mantido para contexto geral)
            trade_summary = []
            if not all_trades.empty:
                last_5_trades = all_trades.sort_values(by='timestamp', ascending=False).head(5)
                for _, trade in last_5_trades.iterrows():
                    trade_summary.append({
                        "trade_id": str(trade.name), "status": trade['status'], "entry_price": trade['entry_price'],
                        "quantity_btc": trade['quantity_btc'], "timestamp": trade['timestamp'].isoformat()
                    })

            # 4. Status e Dados da Binance
            bot_status = {"last_update": datetime.now(timezone.utc).isoformat(), "symbol": self.symbol}
            open_orders_list = self.account_manager.get_open_orders()
            trade_history_list = self.account_manager.get_trade_history(limit=10)

            # 5. Montagem Final do Payload
            status_payload = {
                "portfolio": portfolio_data,
                "session_stats": session_stats,
                "bot_status": bot_status,
                "open_positions_summary": open_positions_summary,  # <-- ADICIONADO
                "trade_summary": trade_summary,
                "open_orders": open_orders_list,
                "trade_history": trade_history_list
            }

            # Escrever no arquivo
            status_file_path = os.path.join("logs", "trading_status.json")
            with open(status_file_path, 'w') as f:
                json.dump(status_payload, f, indent=4)

        except Exception as e:
            logger.error(f"Falha ao atualizar o arquivo de status: {e}", exc_info=True)


    def graceful_shutdown(self, signum: int, frame: Any) -> None:
        """Encerra o bot de forma segura."""
        logger.warning("üö® SINAL DE INTERRUP√á√ÉO RECEBIDO. ENCERRANDO... üö®")
        self.is_running = False
        sys.exit(0)